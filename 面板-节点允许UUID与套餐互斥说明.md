# 节点允许 UUID 与套餐互斥说明

## 现象

- 节点 A 只绑定**基本套餐**，未绑定高级套餐。
- 管理员把用户从**基本套餐**升级到**高级套餐**后，该用户仍然能使用**基本套餐的节点**（在节点机 XP 上查「UUID 状态对比」时，该用户对节点 A 仍显示「面板允许=TRUE」）。
- 期望：升级到高级后，用户**只能**使用高级套餐绑定的节点，**不能**再使用基本套餐的节点。

## 原因分析

1. **`GET /api/internal/nodes/:nodeId/allowed-uuids`** 在计算「允许使用该节点的 UUID」时，可能把用户**所有未过期且已支付的订单**都算进去，没有按**套餐互斥**过滤。
2. 若**基本**和**高级**属于同一互斥总套餐（`plan_groups.is_exclusive = 1`），或管理员可以给同一用户同时保留「基本」和「高级」两个订单，则该用户会同时出现在「基本节点」和「高级节点」的 allowed-uuids 里。

因此需要两处配合：

- **allowed-uuids 计算**：按「互斥组内只认一个有效订单」的规则来算谁能用该节点。
- **管理员操作**：升级时应对同一互斥组内的旧订单做失效/取消，避免用户同时拥有多个互斥套餐的有效订单。

---

## 后端需实现的逻辑

### 1. `GET /api/internal/nodes/:nodeId/allowed-uuids`

**目标**：返回的 UUID 列表 = 当前**有资格**使用该节点的用户（考虑套餐互斥后，每个用户在该节点对应套餐所在互斥组内只保留一个「有效订单」）。

建议实现思路（与现有表结构一致）：

1. **节点 → 套餐**  
   通过 `plan_nodes` 得到该 `nodeId` 对应的所有 `plan_id`。

2. **有效订单**  
   只考虑 `orders.status = 'paid'` 且未过期的订单（过期规则：例如 `orders.paid_at + orders.duration_days` 仍在有效期内）。  
   订单需 JOIN `plans`，再 JOIN `plan_groups`，得到每条订单所属的 `plan_group_id` 和 `plan_groups.is_exclusive`、`plan_groups.level`。

3. **互斥组内只保留一个订单（每个用户）**  
   - 若该节点所属的套餐来自某个 **`is_exclusive = 1`** 的 `plan_group`：
     - 对每个用户，在该互斥组内若有多个有效订单，只保留**一个**作为「有效」订单（例如：取 **`plan_groups.level` 最大** 的那条订单；若 level 相同，可再按 `paid_at` 取最新）。
   - 用这份「每个用户在互斥组内唯一有效订单」的结果，再判断该订单的 `plan_id` 是否在步骤 1 的 `plan_id` 集合里：
     - 若在，则该用户的 UUID 可以进入该节点的 allowed-uuids；
     - 若不在（例如用户在该互斥组内只有「高级」订单，而当前节点只属于「基本」套餐），则该用户**不能**进入该节点的 allowed-uuids。

4. **非互斥 / 多组**  
   - 若节点绑定的套餐所在总套餐 `is_exclusive = 0`，则按现有逻辑（该用户有任意一个有效订单的 plan 包含该节点即可）一般即可。
   - 若节点绑定的套餐涉及多个总套餐（不同 group），则对每个 group 分别做上述互斥组内「只保留一个订单」的判断，再综合：只要有一个有效订单的 plan 包含该节点，且该订单在其所属互斥组内被选为「有效」，则该用户可进入 allowed-uuids。

5. **UUID 来源**  
   从 `user_clients` 或当前系统里「用户 ↔ UUID」的映射表取该用户的 UUID，仅返回这些 UUID（去重）。

按上述方式实现后，即使用户历史上既有基本订单又有高级订单，只要在**互斥组内只认一个有效订单（如 level 最高）**，升级到高级后就不会再出现在「仅绑定基本套餐」的节点的 allowed-uuids 里。

### 2. 管理员「升级」用户套餐时的行为

为避免数据上出现「同一用户在同一互斥组内有多条有效订单」：

- **方式 A（推荐）**：管理员将用户从基本升级到高级时，在创建/支付高级订单的同时，**自动将用户在该互斥组内原有的有效订单**做失效或取消（例如将原订单 `status` 改为 `cancelled` 或标记为被升级替换，具体以你现有订单状态设计为准）。
- **方式 B**：不自动取消旧订单，但 **allowed-uuids 必须**按上面第 1 条实现「互斥组内只认一个有效订单（如 level 最高）」。这样即使用户同时有两条订单，节点侧也只会按「高级」算，不会再用到「基本」的节点。

建议同时做 **A + B**：  
- 业务上升级时尽量只保留一个有效订单（A）；  
- 接口上严格按互斥规则计算 allowed-uuids（B），防止历史数据或其它入口导致「两个都有效」的情况。

### 3. 管理员「强制开通多个互斥套餐」的说明

若产品上允许管理员给同一用户**同时**开通多个互斥套餐（例如既开通基本又开通高级），则必须在 **allowed-uuids** 中明确规则：

- **互斥组内只认一个有效订单**（例如 level 最高的一条），这样：
  - 节点 A 只绑基本 → 只允许「当前有效订单是基本」的用户；
  - 节点 B 只绑高级 → 只允许「当前有效订单是高级」的用户；
  - 同一用户不会同时出现在 A 和 B 的 allowed-uuids 中，除非你明确设计为「不互斥」或「多组可叠加」。

当前需求是「升级到高级后不能再使用基本节点」，因此**必须**在 allowed-uuids 中实现「互斥组内只认一个有效订单（如 level 最高）」，与管理员是否能为用户开多个互斥订单无关。

---

## 小结

| 项目 | 说明 |
|------|------|
| **现象** | 用户从基本升级到高级后，仍能使用仅绑定基本套餐的节点。 |
| **原因** | allowed-uuids 未按套餐互斥过滤；或升级时未取消/失效旧订单。 |
| **接口** | `GET /api/internal/nodes/:nodeId/allowed-uuids` 需按「节点所属套餐 → 总套餐是否互斥 → 每个用户在互斥组内只保留一个有效订单（如 level 最高）」计算 UUID。 |
| **升级** | 管理员升级用户时，建议同时取消/失效该用户在互斥组内的旧订单。 |
| **多订单** | 即允许管理员强制开多个互斥套餐，allowed-uuids 仍应只按「互斥组内一个有效订单」计算，保证升级后不会再用到低档节点。 |

实现上述逻辑后，节点机上的「UUID 状态对比」会与预期一致：升级到高级后，该用户对「仅绑定基本套餐」的节点将变为「面板允许=FALSE」。
